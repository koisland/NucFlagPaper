from copy import deepcopy
from os.path import join
from collections import defaultdict


"""
{
    Literal["output_dir"]: str,
    Literal["logs_dir"]: str,
    Literal["benchmarks_dir"]: str,
    Literal["samples"]: {
        str: {
            Literal["asm_fa"]: str,
            Literal["reads"]: list[str],
            Literal["preset"]: str
        }
    }
}
"""
SAMPLES = config["samples"]

OUTPUT_DIR = config["output_dir"]
NUCFLAG_OUTPUT_DIR = join(OUTPUT_DIR, "nucflag")
MISASIM_OUTPUT_DIR = join(OUTPUT_DIR, "simulated")

LOG_DIR = config["logs_dir"]
NUCFLAG_LOG_DIR = join(LOG_DIR, "nucflag")
MISASIM_LOG_DIR = join(LOG_DIR, "simulated")

BENCHMARK_DIR = config["benchmarks_dir"]
NUCFLAG_BENCHMARK_DIR = join(BENCHMARK_DIR, "nucflag")
MISASIM_BENCHMARK_DIR = join(BENCHMARK_DIR, "simulated")


wildcard_constraints:
    sm="|".join(SAMPLES.keys()),


NUM = 10_000
LEN = config.get("lengths", [10, 50, 500, 1_000, 10_000, 50_000])
MTYPES = config.get("mtype", ["misjoin", "false-duplication", "gap", "inversion"])
DOWNSAMPLE_PERC = [0.50, 0.33]
ALL_MTYPES = [
    {"mtype": mtype, "num": NUM, "length": length}
    for mtype in MTYPES
    for length in LEN
]
ALL_MTYPES_SEEDED = dict(zip(range(len(ALL_MTYPES)), ALL_MTYPES))

# Run NucFlag on original assembly on original reads.
config_base = {
    "samples": [{"name": sm, **cfg} for sm, cfg in SAMPLES.items()],
    "output_dir": NUCFLAG_OUTPUT_DIR,
    "output_pileup": False,
    "logs_dir": NUCFLAG_LOG_DIR,
    "benchmarks_dir": NUCFLAG_BENCHMARK_DIR,
    "threads_aln": 24,
    "mem_aln": "50G",
    "processes_nucflag": 12,
    "threads_nucflag": 2,
    "mem_nucflag": "50G",
    "samtools_view_flag": 2308,
}

# Downsample reads by 100%, 75%, 50%
rule downsample_reads:
    input:
        reads=lambda wc: SAMPLES[wc.sm]["reads"],
    output:
        join(OUTPUT_DIR, "reads", "{sm}_{perc}.fastq.gz"),
    params:
        sample="{perc}",
    conda:
        "../../envs/misasim.yaml"
    log:
        join(LOG_DIR, "downsample_reads_{sm}_{perc}.log"),
    shell:
        """
        seqtk sample <(zcat {input}) {params.sample} | bgzip > {output}
        """


# Generate misassemblies
module misasim:
    snakefile:
        "misasim.smk"
    config:
        {
            "output_dir": MISASIM_OUTPUT_DIR,
            "log_dir": MISASIM_LOG_DIR,
            "samples": {
                sm: {
                    "fa": SAMPLES[sm]["asm_fa"],
                    "seed_opts": ALL_MTYPES_SEEDED,
                }
                for sm in SAMPLES.keys()
            },
        }


use rule * from misasim as ms_*


# Misassemblies
config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['num']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": SAMPLES[sm]["reads"],
            "preset": "ont_r10" if SAMPLES[sm]["preset"] == "ont" else SAMPLES[sm]["preset"],
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)
# Misassemblies
config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['num']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": expand(
                rules.downsample_reads.output, sm=sm, perc=perc
            ),
            "preset": "ont_r10" if SAMPLES[sm]["preset"] == "ont" else SAMPLES[sm]["preset"],
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


# rule split_asm:
#     input:
#         fa=ASM_FA,
#         fai=f"{ASM_FA}.fai",
#     output:
#         join("results", "flagger", "seq", f"{SAMPLE}_{{hap}}.fa")
#     conda:
#         "env.yaml"
#     shell:
#         """
#         seqtk subseq {input.fa} <(grep {wildcards.hap} {input.fai} | cut -f 1) > {output}
#         """


# module Flagger:
#     snakefile:
#         "flagger.smk"
#     config:
#         {
#             "output_dir": join("results", "flagger", "original", SAMPLE),
#             "samples": [
#                 {
#                     "sm_id": f"{SAMPLE}_original",
#                     "asm_1": expand(rules.split_asm.output, hap="MATERNAL")[0],
#                     "asm_2": expand(rules.split_asm.output, hap="PATERNAL")[0],
#                     "alpha": "flagger/misc/alpha_tsv/HiFi_DC_1.2/alpha_optimum_trunc_exp_gaussian_w_16000_n_50.HiFi_DC_1.2_DEC_2024.v1.1.0.tsv",
#                     "reads": expand(GLOB_HIFI, fname=HIFI_FNAMES),
#                 }
#             ]
#         }

# use rule * from Flagger


module NucFlag:
    snakefile:
        "Snakemake-NucFlag/workflow/Snakefile"
    config:
        config_base


use rule * from NucFlag as nf_*


# FLAGGER_CFG = {
#     "output_dir": join("results", "flagger", "simulated"),
#     "samples": [
#         {
#             "sm_id": f"HG002_misasim_{perc}_{mtype}_{num}_{length}",
#             "asm_1": expand(rules.split_asm_misasim.output, seed=seed, hap="MATERNAL")[0],
#             "asm_2": expand(rules.split_asm_misasim.output, seed=seed, hap="PATERNAL")[0],
#             "alpha": "flagger/misc/alpha_tsv/HiFi_DC_1.2/alpha_optimum_trunc_exp_gaussian_w_16000_n_50.HiFi_DC_1.2_DEC_2024.v1.1.0.tsv",
#             "reads": expand(rules.downsample_reads.output, fname=HIFI_FNAMES, perc=perc),
#         }
#         for perc in DOWNSAMPLE_PERC
#         for seed, (mtype, num, length) in ALL_MTYPES_SEEDED.items()
#     ]
# }

# module FlaggerSubsetMisasim:
#     snakefile:
#         "flagger.smk"
#     config:
#         FLAGGER_CFG

# use rule * from FlaggerSubsetMisasim as misasim_*


# TODO: Test minimap2 lr:hqae, winnowmap map-ont, pbmm2 CCS, pbmm2 SUBREAD. First 10 seeds.
# TODO: Calculate precision and recall on all n seeds.


rule all:
    input:
        rules.nf_nucflag.input,
        # rules.flagger.input,
        # rules.misasim_flagger.input
    default_target: True
