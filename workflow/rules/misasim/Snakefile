import hashlib
from copy import deepcopy
from os.path import join
from collections import defaultdict


"""
{
    Literal["output_dir"]: str,
    Literal["logs_dir"]: str,
    Literal["benchmarks_dir"]: str,
    Literal["samples"]: {
        str: {
            Literal["asm_fa"]: str,
            Literal["reads"]: list[str],
            Literal["preset"]: str
        }
    }
}
"""
SAMPLES = config["samples"]

OUTPUT_DIR = config["output_dir"]
NUCFLAG_OUTPUT_DIR = join(OUTPUT_DIR, "nucflag")
MISASIM_OUTPUT_DIR = join(OUTPUT_DIR, "simulated")
SUMMARY_OUTPUT_DIR = join(OUTPUT_DIR, "summary")

LOG_DIR = config["logs_dir"]
NUCFLAG_LOG_DIR = join(LOG_DIR, "nucflag")
MISASIM_LOG_DIR = join(LOG_DIR, "simulated")
SUMMARY_LOG_DIR = join(LOG_DIR, "summary")

BENCHMARK_DIR = config["benchmarks_dir"]
NUCFLAG_BENCHMARK_DIR = join(BENCHMARK_DIR, "nucflag")
MISASIM_BENCHMARK_DIR = join(BENCHMARK_DIR, "simulated")
SUMMARY_BENCHMARK_DIR = join(BENCHMARK_DIR, "summary")


wildcard_constraints:
    sm="|".join(SAMPLES.keys()),


NUM = 100
LEN = config.get("lengths", [1, 2, 10, 100, 1_000, 10_000, 50_000])
MTYPES = config.get("mtype", ["misjoin", "false_duplication", "inversion"])
DOWNSAMPLE_PERC = [0.50, 0.33]
ALL_MTYPES_SEEDED = {
    # https://stackoverflow.com/a/67219726
    int.from_bytes(
        hashlib.sha256(f"{mtype}_{NUM}_{length}".encode()).digest()[:4],
        'little'
    ): {"mtype": mtype, "number": NUM, "length": length}
    for mtype in MTYPES
    for length in LEN
}

# Run NucFlag on original assembly on original reads.
nf_config_base = {
    "samples": [{"name": sm, **cfg} for sm, cfg in SAMPLES.items()],
    "output_dir": NUCFLAG_OUTPUT_DIR,
    "output_pileup": False,
    "logs_dir": NUCFLAG_LOG_DIR,
    "benchmarks_dir": NUCFLAG_BENCHMARK_DIR,
    "threads_aln": 24,
    "mem_aln": "50G",
    "processes_nucflag": 12,
    "threads_nucflag": 12,
    "mem_nucflag": "50G",
    # Filter unmapped, non-primary, and supplementary alignments.
    "samtools_view_flag": 2308,
}


# Downsample reads by 100%, 75%, 50%
rule downsample_reads:
    input:
        reads=lambda wc: SAMPLES[wc.sm]["reads"],
    output:
        join(OUTPUT_DIR, "reads", "{sm}_{perc}.fastq.gz"),
    params:
        sample="{perc}",
    conda:
        "../../envs/misasim.yaml"
    log:
        join(LOG_DIR, "downsample_reads_{sm}_{perc}.log"),
    shell:
        """
        seqtk sample <(zcat -f {input}) {params.sample} | bgzip > {output}
        """


# Generate misassemblies
module misasim:
    snakefile:
        "misasim.smk"
    config:
        {
            "output_dir": MISASIM_OUTPUT_DIR,
            "log_dir": MISASIM_LOG_DIR,
            "samples": {
                sm: {
                    "fa": SAMPLES[sm]["asm_fa"],
                    "seed_opts": ALL_MTYPES_SEEDED,
                }
                for sm in SAMPLES.keys()
            },
        }


use rule * from misasim as ms_*


# Misassemblies
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": SAMPLES[sm]["reads"],
            "config": SAMPLES[sm]["config"],
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "reads": expand(rules.downsample_reads.output, sm=sm, perc=perc),
            "config": SAMPLES[sm]["config"],
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)
# Misassemblies downsampled
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": expand(rules.downsample_reads.output, sm=sm, perc=perc),
            "config": SAMPLES[sm]["config"],
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module NucFlag:
    snakefile:
        "Snakemake-NucFlag/workflow/Snakefile"
    config:
        nf_config_base


use rule * from NucFlag


flagger_config_base = {
    "output_dir": join("results", "misasim", "flagger"),
    "benchmarks_dir": join("benchmarks", "misasim", "flagger"),
    "logs_dir": join("logs", "misasim", "flagger"),
    "samples": [
        {
            "name": sm,
            "asm_fa": SAMPLES[sm]["asm_fa"],
            "bam": join(NUCFLAG_OUTPUT_DIR, f"{sm}.bam"),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
    ],
}

# Misassemblies
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": join(
                NUCFLAG_OUTPUT_DIR,
                f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}.bam",
            ),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "bam": join(NUCFLAG_OUTPUT_DIR, f"{sm}_{perc}.bam"),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)

# Misassemblies downsampled
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": join(
                NUCFLAG_OUTPUT_DIR,
                f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}.bam",
            ),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module Flagger:
    snakefile:
        "flagger.smk"
    config:
        flagger_config_base


use rule * from Flagger


inspector_config_base = {
    "output_dir": join("results", "misasim", "inspector"),
    "benchmarks_dir": join("benchmarks", "misasim", "inspector"),
    "logs_dir": join("logs", "misasim", "inspector"),
    "samples": [
        {
            "name": sm,
            "asm_fa": SAMPLES[sm]["asm_fa"],
            "bam": join(NUCFLAG_OUTPUT_DIR, f"{sm}.bam"),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
    ],
}

# Misassemblies
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": join(
                NUCFLAG_OUTPUT_DIR,
                f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}.bam",
            ),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "bam": join(NUCFLAG_OUTPUT_DIR, f"{sm}_{perc}.bam"),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)

# Misassemblies downsampled
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": join(
                NUCFLAG_OUTPUT_DIR,
                f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}.bam",
            ),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module Inspector:
    snakefile:
        "inspector.smk"
    config:
        inspector_config_base


use rule * from Inspector


rule calculate_precision_recall:
    input:
        script="workflow/scripts/misasim/calculate_precision_recall.py",
        chkpt=[rules.nucflag.input, rules.ms_all.input],
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "nucflag_{sm}.tsv")
    params:
        fglob_test="*_misassemblies.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=lambda wc: wc.sm.split("_", 1)[1],
        output_dir=NUCFLAG_OUTPUT_DIR,
        sim_output_dir=MISASIM_OUTPUT_DIR,
    shell:
        """
        python {input.script} \
        -a {params.output_dir} \
        --glob_test "{params.fglob_test}" \
        -b {params.sim_output_dir} \
        --glob_truth "{params.fglob_truth}" \
        -d {params.dtype} > {output}
        """

use rule calculate_precision_recall as calculate_precision_recall_inspector with:
    input:
        script="workflow/scripts/misasim/calculate_precision_recall.py",
        chkpt=[rules.inspector.input, rules.ms_all.input],
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "inspector_{sm}.tsv")
    params:
        fglob_test="*.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=lambda wc: wc.sm.split("_", 1)[1],
        output_dir=join("results", "misasim", "inspector"),
        sim_output_dir=MISASIM_OUTPUT_DIR,

use rule calculate_precision_recall as calculate_precision_recall_flagger with:
    input:
        script="workflow/scripts/misasim/calculate_precision_recall.py",
        chkpt=rules.flagger.input,
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "flagger_{sm}.tsv")
    params:
        fglob_test="*/*.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=lambda wc: wc.sm.split("_", 1)[1],
        output_dir=join("results", "misasim", "flagger"),
        sim_output_dir=MISASIM_OUTPUT_DIR,

rule all:
    input:
        rules.nucflag.input,
        rules.flagger.input,
        rules.inspector.input,
        expand(rules.calculate_precision_recall.output, sm=SAMPLES),
        expand(rules.calculate_precision_recall_inspector.output, sm=SAMPLES),
        expand(rules.calculate_precision_recall_flagger.output, sm=SAMPLES),
    default_target: True
