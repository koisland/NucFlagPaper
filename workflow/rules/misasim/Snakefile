from copy import deepcopy
from os.path import join
from collections import defaultdict


include: "../common.smk"


"""
{
    Literal["output_dir"]: str,
    Literal["logs_dir"]: str,
    Literal["benchmarks_dir"]: str,
    Literal["samples"]: {
        str: {
            Literal["asm_fa"]: str,
            Literal["reads"]: list[str],
            Literal["config"]: str,
            Literal["flagger_config"]: str,
            Literal["group_by"]: str,
        }
    }
}
"""

SAMPLES = config["samples"]

OUTPUT_DIR = config["output_dir"]
NUCFLAG_OUTPUT_DIR = join(OUTPUT_DIR, "nucflag")
MISASIM_OUTPUT_DIR = join(OUTPUT_DIR, "simulated")
SUMMARY_OUTPUT_DIR = join(OUTPUT_DIR, "summary")

LOG_DIR = config["logs_dir"]
NUCFLAG_LOG_DIR = join(LOG_DIR, "nucflag")
MISASIM_LOG_DIR = join(LOG_DIR, "simulated")
SUMMARY_LOG_DIR = join(LOG_DIR, "summary")

BENCHMARK_DIR = config["benchmarks_dir"]
NUCFLAG_BENCHMARK_DIR = join(BENCHMARK_DIR, "nucflag")
MISASIM_BENCHMARK_DIR = join(BENCHMARK_DIR, "simulated")
SUMMARY_BENCHMARK_DIR = join(BENCHMARK_DIR, "summary")


DOWNSAMPLE_PERC = config.get("downsample_perc", [0.50, 0.33])
ALL_MTYPES_SEEDED = config["seeded_mtypes"]


wildcard_constraints:
    sm="|".join(SAMPLES.keys()),
    perc="|".join(str(p) for p in DOWNSAMPLE_PERC),


# Run NucFlag on original assembly on original reads.
nf_config_base = {
    "samples": [{"name": sm, **cfg} for sm, cfg in SAMPLES.items()],
    "output_dir": NUCFLAG_OUTPUT_DIR,
    "output_plots": False,
    "output_pileup": False,
    "logs_dir": NUCFLAG_LOG_DIR,
    "benchmarks_dir": NUCFLAG_BENCHMARK_DIR,
    "threads_aln": 24,
    "mem_aln": "50G",
    "processes_nucflag": 24,
    "threads_nucflag": 12,
    "mem_nucflag": "50G",
    # Filter unmapped, non-primary, and supplementary alignments.
    "samtools_view_flag": 2308,
    "output_format": "cram",
}


# Downsample reads by 100%, 75%, 50%
rule downsample_reads:
    input:
        reads=lambda wc: SAMPLES[wc.sm]["reads"],
    output:
        join(OUTPUT_DIR, "reads", "{sm}_{perc}.fastq.gz"),
    params:
        sample="{perc}",
    conda:
        "../../envs/misasim.yaml"
    log:
        join(LOG_DIR, "downsample_reads_{sm}_{perc}.log"),
    shell:
        """
        seqtk sample <(zcat -f {input}) {params.sample} | bgzip > {output}
        """


# Generate misassemblies
module misasim:
    snakefile:
        "misasim.smk"
    config:
        {
            "output_dir": MISASIM_OUTPUT_DIR,
            "log_dir": MISASIM_LOG_DIR,
            "samples": {
                sm: {
                    "fa": SAMPLES[sm]["asm_fa"],
                    "seed_opts": ALL_MTYPES_SEEDED,
                    "group_by": SAMPLES[sm].get("group_by", r"^(.*?)$"),
                }
                for sm in SAMPLES.keys()
            },
        }


use rule * from misasim as ms_*


# Misassemblies
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": SAMPLES[sm]["reads"],
            "config": SAMPLES[sm]["config"],
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "reads": expand(rules.downsample_reads.output, sm=sm, perc=perc),
            "config": SAMPLES[sm]["config"],
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)
# Misassemblies downsampled
nf_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "reads": expand(rules.downsample_reads.output, sm=sm, perc=perc),
            "config": SAMPLES[sm]["config"],
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module NucFlag:
    snakefile:
        "../Snakemake-NucFlag/workflow/Snakefile"
    config:
        nf_config_base


nf_config_by_sm = {sm_cfg["name"]: sm_cfg for sm_cfg in nf_config_base["samples"]}


use rule * from NucFlag


rule create_tmp_bam:
    input:
        bam=lambda wc: rules.aln_merge_read_asm_alignments.output.alignment.format(
            sm=wc.sm_cond
        ),
        fa=lambda wc: nf_config_by_sm[wc.sm_cond]["asm_fa"],
    output:
        bam=temp(join(NUCFLAG_OUTPUT_DIR, "{sm_cond}.tmp.bam")),
    conda:
        "../../envs/misasim.yaml"
    shell:
        """
        samtools view -T {input.fa} {input.bam} -o {output.bam}
        samtools index {output.bam}
        """


flagger_config_base = {
    "output_dir": join("results", "misasim", "flagger"),
    "benchmarks_dir": join("benchmarks", "misasim", "flagger"),
    "logs_dir": join("logs", "misasim", "flagger"),
    "samples": [
        {
            "name": sm,
            "asm_fa": SAMPLES[sm]["asm_fa"],
            "bam": expand(rules.create_tmp_bam.output, sm_cond=sm),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
    ],
}

# Misassemblies
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": expand(
                rules.create_tmp_bam.output,
                sm_cond=f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            ),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "bam": expand(rules.create_tmp_bam.output, sm_cond=f"{sm}_{perc}"),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)

# Misassemblies downsampled
flagger_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": expand(
                rules.create_tmp_bam.output,
                sm_cond=f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            ),
            "alpha": SAMPLES[sm]["flagger_config"],
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module Flagger:
    snakefile:
        "../flagger.smk"
    config:
        flagger_config_base


use rule * from Flagger


inspector_config_base = {
    "output_dir": join("results", "misasim", "inspector"),
    "benchmarks_dir": join("benchmarks", "misasim", "inspector"),
    "logs_dir": join("logs", "misasim", "inspector"),
    "samples": [
        {
            "name": sm,
            "asm_fa": SAMPLES[sm]["asm_fa"],
            "bam": expand(rules.create_tmp_bam.output, sm_cond=sm),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
    ],
}

# Misassemblies
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": expand(
                rules.create_tmp_bam.output,
                sm_cond=f"{sm}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            ),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)

# Downsampled
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}",
            "asm_fa": cfg["asm_fa"],
            "bam": expand(rules.create_tmp_bam.output, sm_cond=f"{sm}_{perc}"),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm, cfg in SAMPLES.items()
        for perc in DOWNSAMPLE_PERC
    ]
)

# Misassemblies downsampled
inspector_config_base["samples"].extend(
    [
        {
            "name": f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            "asm_fa": join(MISASIM_OUTPUT_DIR, sm, f"{seed}.fa"),
            "bam": expand(
                rules.create_tmp_bam.output,
                sm_cond=f"{sm}_{perc}_{cfg['mtype']}-{cfg['number']}-{cfg['length']}",
            ),
            "datatype": "nanopore" if "ont" in sm else "hifi",
        }
        for sm in SAMPLES.keys()
        for perc in DOWNSAMPLE_PERC
        for seed, cfg in ALL_MTYPES_SEEDED.items()
    ]
)


module Inspector:
    snakefile:
        "../inspector.smk"
    config:
        inspector_config_base


use rule * from Inspector


rule calculate_precision_recall:
    input:
        script="workflow/scripts/metrics/calculate_precision_recall.py",
        chkpt=[rules.nucflag.input, rules.ms_all.input],
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "nucflag_{sm}.tsv"),
        missed_calls_dir=directory(join(SUMMARY_OUTPUT_DIR, "nucflag_{sm}_missed")),
    params:
        fglob_test=lambda wc: f"{wc.sm}*_misassemblies.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=get_dtype,
        output_dir=NUCFLAG_OUTPUT_DIR,
        sim_output_dir=MISASIM_OUTPUT_DIR,
    conda:
        "../../envs/misasim.yaml"
    shell:
        """
        python {input.script} \
        -a {params.output_dir} \
        --glob_test "{params.fglob_test}" \
        -b {params.sim_output_dir} \
        --glob_truth "{params.fglob_truth}" \
        -d {params.dtype} \
        --output_dir_missed_calls {output.missed_calls_dir} > {output.summary}
        """


use rule calculate_precision_recall as calculate_precision_recall_inspector with:
    input:
        script="workflow/scripts/metrics/calculate_precision_recall.py",
        chkpt=[rules.inspector.input, rules.ms_all.input],
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "inspector_{sm}.tsv"),
        missed_calls_dir=directory(join(SUMMARY_OUTPUT_DIR, "inspector_{sm}_missed")),
    params:
        fglob_test=lambda wc: f"{wc.sm}*.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=get_dtype,
        output_dir=join("results", "misasim", "inspector"),
        sim_output_dir=MISASIM_OUTPUT_DIR,


use rule calculate_precision_recall as calculate_precision_recall_flagger with:
    input:
        script="workflow/scripts/metrics/calculate_precision_recall.py",
        chkpt=rules.flagger.input,
    output:
        summary=join(SUMMARY_OUTPUT_DIR, "flagger_{sm}.tsv"),
        missed_calls_dir=directory(join(SUMMARY_OUTPUT_DIR, "flagger_{sm}_missed")),
    params:
        fglob_test=lambda wc: f"{wc.sm}*/*.bed",
        fglob_truth=lambda wc: f"{wc.sm}/*.bed",
        dtype=get_dtype,
        output_dir=join("results", "misasim", "flagger"),
        sim_output_dir=MISASIM_OUTPUT_DIR,


rule plot_precision_recall:
    input:
        script="workflow/scripts/metrics/plot_precision_recall.py",
        summaries=[
            rules.calculate_precision_recall.output.summary,
            rules.calculate_precision_recall_inspector.output.summary,
            rules.calculate_precision_recall_flagger.output.summary,
        ],
    output:
        directory(join(SUMMARY_OUTPUT_DIR, "{sm}")),
    params:
        output_prefix=lambda wc, output: f"{output[0]}",
    conda:
        "../../envs/misasim.yaml"
    shell:
        """
        python {input.script} -i {input.summaries} -o {params.output_prefix}/
        """


rule all:
    input:
        rules.nucflag.input,
        rules.flagger.input,
        rules.inspector.input,
        expand(rules.calculate_precision_recall.output, sm=SAMPLES),
        expand(rules.calculate_precision_recall_inspector.output, sm=SAMPLES),
        expand(rules.calculate_precision_recall_flagger.output, sm=SAMPLES),
        expand(rules.plot_precision_recall.output, sm=SAMPLES),
    default_target: True
