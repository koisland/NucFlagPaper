from os.path import join
from collections import defaultdict


OUTPUT_DIR = config["output_dir"]
LOG_DIR = config["logs_dir"]
BENCHMARK_DIR = config["benchmarks_dir"]
# {sample: {dtype: { R1: [], R2: []}}}
DATA = defaultdict(lambda: defaultdict(dict))
RELEASES = ["R1", "R2"]

with open(config["manifest"]) as fh:
    # Skip header.
    next(fh)
    for line in fh:
        sample, asm_h1, asm_h2, bam, release = line.strip().split(",")
        DATA[sample]["asm"][release] = [asm_h1, asm_h2]
        DATA[sample]["bam"][release] = [bam]


wildcard_constraints:
    sm="|".join(DATA.keys()),
    release="|".join(RELEASES),


rule download_assemblies:
    output:
        asm=join(OUTPUT_DIR, "data", "{sm}_{release}.fa.gz"),
        asm_fai=join(OUTPUT_DIR, "data", "{sm}_{release}.fa.gz.fai"),
    params:
        uris=lambda wc: DATA[wc.sm]["asm"][wc.release],
    conda:
        # TODO: Consolidate envs
        "../../envs/curated.yaml"
    shell:
        """
        for uri in {params.uris}; do
            aws s3 --no-sign-request cp "${{uri}}" - | zcat | bgzip >> {output.asm}
        done
        samtools faidx {output.asm}
        """


rule download_aligned_bams:
    output:
        bam=join(OUTPUT_DIR, "data", "{sm}_{release}.bam"),
        bai=join(OUTPUT_DIR, "data", "{sm}_{release}.bam.bai"),
    params:
        uri=lambda wc: DATA[wc.sm]["bam"][wc.release],
    conda:
        "../../envs/curated.yaml"
    shell:
        """
        aws s3 --no-sign-request cp {params.uri} {output.bam}
        aws s3 --no-sign-request cp {params.uri}.bai {output.bai}
        """


rule run_nucflag:
    input:
        bam=rules.download_aligned_bams.output.bam,
        asm=rules.download_assemblies.output.asm,
    output:
        calls=join(
            OUTPUT_DIR,
            "{sm}_{release}.bed",
        ),
    params:
        preset="hifi",
    conda:
        "../Snakemake-NucFlag/workflow/env/nucflag.yaml"
    threads: 12
    resources:
        threads=12,
        mem="50GB",
    log:
        join(LOG_DIR, "run_nucflag_{sm}_{release}.log"),
    benchmark:
        join(BENCHMARK_DIR, "run_nucflag_{sm}_{release}.tsv")
    shell:
        """
        nucflag call \
        -i {input.bam} \
        -f {input.asm} \
        -x {params.preset} \
        -o {output.calls} \
        -t {resources.threads} \
        -p {threads} 2> {log}
        """


rule calculate_qv:
    input:
        calls=rules.run_nucflag.output.calls,
    output:
        qv=join(
            OUTPUT_DIR,
            "{sm}_{release}_{ignore}.qv.bed",
        ),
    params:
        ignore=lambda wc: f"-c {wc.ignore}" if wc.ignore != "none" else "",
    conda:
        "../Snakemake-NucFlag/workflow/env/nucflag.yaml"
    shell:
        """
        nucflag qv -i {input.calls} {params.ignore} > {output.qv}
        """


# QV scatter plot
rule plot_qv_comparison:
    input:
        qv_r1=expand(
            rules.calculate_qv.output, sm=DATA.keys(), release="R1", ignore="{ignore}"
        ),
        qv_r2=expand(
            rules.calculate_qv.output, sm=DATA.keys(), release="R2", ignore="{ignore}"
        ),
    output:
        qv=join(OUTPUT_DIR, "plots", "hprc_qv_comparison_{ignore}.tsv"),
        png=join(OUTPUT_DIR, "plots", "hprc_qv_comparison_{ignore}.png"),
    params:
        script="workflow/scripts/compare_hprc/plot_qv_compare.py",
    conda:
        "../../envs/tools.yaml"
    shell:
        """
        python {params.script} \
        -a <(cat {input.qv_r1}) \
        -b <(cat {input.qv_r2}) \
        -o {output.qv} \
        -p {output.png}
        """


rule all:
    input:
        expand(rules.download_assemblies.output, sm=DATA.keys(), release=RELEASES),
        expand(rules.download_aligned_bams.output, sm=DATA.keys(), release=RELEASES),
        expand(
            rules.calculate_qv.output,
            sm=DATA.keys(),
            release=RELEASES,
            ignore=["scaffold", "none"],
        ),
        expand(rules.plot_qv_comparison.output, ignore=["scaffold", "none"]),
    default_target: True
