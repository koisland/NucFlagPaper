from os.path import join
from collections import defaultdict


OUTPUT_DIR = config["output_dir"]
LOG_DIR = config["logs_dir"]
BENCHMARK_DIR = config["benchmarks_dir"]
# {sample: {dtype: { R1: [], R2: []}}}
DATA = defaultdict(lambda: defaultdict(dict))
RELEASES = ["R1", "R2"]

with open(config["manifest"]) as fh:
    # Skip header.
    next(fh)
    for line in fh:
        sample, asm_h1, asm_h2, bam, release = line.strip().split(",")
        DATA[sample]["asm"][release] = [asm_h1, asm_h2]
        DATA[sample]["bam"][release] = [bam]


wildcard_constraints:
    sm="|".join(DATA.keys()),
    release="|".join(RELEASES),


rule download_assemblies:
    output:
        asm=join(OUTPUT_DIR, "data", "{sm}_{release}.fa.gz"),
        asm_fai=join(OUTPUT_DIR, "data", "{sm}_{release}.fa.gz.fai"),
    params:
        uris=lambda wc: DATA[wc.sm]["asm"][wc.release],
    conda:
        # TODO: Consolidate envs
        "../../envs/curated.yaml"
    shell:
        """
        for uri in {params.uris}; do
            aws s3 --no-sign-request cp "${{uri}}" - | zcat | bgzip >> {output.asm}
        done
        samtools faidx {output.asm}
        """


rule download_aligned_bams:
    output:
        bam=join(OUTPUT_DIR, "data", "{sm}_{release}.bam"),
        bai=join(OUTPUT_DIR, "data", "{sm}_{release}.bam.bai"),
    params:
        uri=lambda wc: DATA[wc.sm]["bam"][wc.release],
    conda:
        "../../envs/curated.yaml"
    shell:
        """
        aws s3 --no-sign-request cp {params.uri} {output.bam}
        aws s3 --no-sign-request cp {params.uri}.bai {output.bai}
        """


rule run_nucflag:
    input:
        bam=rules.download_aligned_bams.output.bam,
        asm=rules.download_assemblies.output.asm,
    output:
        calls=join(
            OUTPUT_DIR,
            "{sm}_{release}.bed",
        ),
    params:
        preset="hifi",
    conda:
        "../Snakemake-NucFlag/workflow/env/nucflag.yaml"
    threads: 12
    resources:
        threads=12,
        mem="50GB",
    log:
        join(LOG_DIR, "run_nucflag_{sm}_{release}.log"),
    benchmark:
        join(BENCHMARK_DIR, "run_nucflag_{sm}_{release}.tsv")
    shell:
        """
        nucflag call \
        -i {input.bam} \
        -f {input.asm} \
        -x {params.preset} \
        -o {output.calls} \
        -t {resources.threads} \
        -p {threads} 2> {log}
        """


rule calculate_qv:
    input:
        calls=rules.run_nucflag.output.calls,
    output:
        qv=join(
            OUTPUT_DIR,
            "{sm}_{release}.qv.bed",
        ),
    conda:
        "../Snakemake-NucFlag/workflow/env/nucflag.yaml"
    shell:
        """
        nucflag qv -i {input.calls} -c scaffold > {output.qv}
        """


# QV scatter plot
rule plot_qv_comparison:
    input:
        qv_r1=expand(
            rules.calculate_qv.output,
            sm=DATA.keys(),
            release="R1",
        ),
        qv_r2=expand(
            rules.calculate_qv.output,
            sm=DATA.keys(),
            release="R2",
        ),
    output:
        qv=join(OUTPUT_DIR, "plots", "hprc_qv_comparison.tsv"),
        dt_qv=join(OUTPUT_DIR, "plots", "hprc_dt_qv_comparison.tsv"),
        png=join(OUTPUT_DIR, "plots", "hprc_qv_comparison.png"),
    params:
        script="workflow/scripts/compare_hprc/plot_qv_compare.py",
    conda:
        "../../envs/tools.yaml"
    shell:
        """
        python {params.script} \
        -a <(cat {input.qv_r1}) \
        -b <(cat {input.qv_r2}) \
        -d {output.dt_qv} \
        -o {output.qv} \
        -p {output.png}
        """


# Plot error
rule plot_err_comparison:
    input:
        calls_r1=expand(
            rules.run_nucflag.output.calls,
            sm=DATA.keys(),
            release="R1",
        ),
        calls_r2=expand(
            rules.run_nucflag.output.calls,
            sm=DATA.keys(),
            release="R2",
        ),
    output:
        png_cmp_sm=join(OUTPUT_DIR, "plots", "hprc_err_comparison_by_sm.png"),
        png_diff_by_name=join(
            OUTPUT_DIR, "plots", "hprc_err_comparison_diff_by_name.png"
        ),
        sm_diff=join(OUTPUT_DIR, "plots", "hprc_err_comparison_by_sample.tsv"),
        name_diff=join(OUTPUT_DIR, "plots", "hprc_err_comparison_by_name.tsv"),
        sm_name_diff=join(
            OUTPUT_DIR, "plots", "hprc_err_comparison_by_sample_and_name.tsv"
        ),
    params:
        script="workflow/scripts/compare_hprc/plot_err_compare.py",
    conda:
        "../../envs/tools.yaml"
    shell:
        """
        python {params.script} \
        -a <(cat {input.calls_r1}) \
        -b <(cat {input.calls_r2}) \
        -nd {output.name_diff} \
        -sd {output.sm_diff} \
        -snd {output.sm_name_diff} \
        -o {output.png_cmp_sm} \
        -n {output.png_diff_by_name}
        """


# UL ont coverage increases by 24.0x.
rule plot_ul_ont:
    input:
        mdata_r1="data/compare_hprc/hprc_r1_data.tsv.gz",
        mdata_r2="data/compare_hprc/hprc_r2_data.csv.gz",
    output:
        plot=join(OUTPUT_DIR, "plots", "hprc_ul_ont.png"),
    params:
        script="workflow/scripts/compare_hprc/summarize_ul_ont_diff.py",
    conda:
        "../../envs/tools.yaml"
    shell:
        """
        python {params.script} \
        {input.mdata_r1} \
        {input.mdata_r2} \
        {output.plot}
        """


rule all:
    input:
        expand(rules.download_assemblies.output, sm=DATA.keys(), release=RELEASES),
        expand(rules.download_aligned_bams.output, sm=DATA.keys(), release=RELEASES),
        expand(
            rules.calculate_qv.output,
            sm=DATA.keys(),
            release=RELEASES,
        ),
        rules.plot_qv_comparison.output,
        rules.plot_err_comparison.output,
        rules.plot_ul_ont.output,
    default_target: True
